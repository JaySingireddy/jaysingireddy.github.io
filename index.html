<!DOCTYPE html><html><head><title>Tutorials</title><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui=1"><meta charset="UTF-8"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="description" content=""><link rel="manifest" href="manifest.json"><link rel="icon" type="image/png" href="icon64.png"><link rel="apple-touch-icon" sizes="180x180" href="icon180.png"><link rel="icon" type="image/png" sizes="32x32" href="icon32.png"><link rel="icon" type="image/png" sizes="16x16" href="icon16.png"><style>html,body {
  margin: 0;
  padding: 0;
  background-color: #000;
  overflow:hidden;
  font-family: Verdana;
}
.noselect {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
#canvaswrapper {
  text-align: center ;
}
</style><style>@font-face { font-family: "BitCell" ; src: url("fonts/BitCell.ttf") format("truetype"); }</style><script>window.fonts = ["BitCell"]</script></head><body class="noselect custom-cursor" oncontextmenu="return false;"><div id="canvaswrapper"></div><script type="text/javascript">var resources = {"images":[{"file":"icon.png","version":0,"size":0,"properties":{}}],"assets":[],"maps":{},"sounds":[],"music":[]};
var graphics = "M1";

</script><script type="text/javascript">var orientation = 'any' ;
var aspect = 'free' ;
var ms_libs = [] ;
window.skip_service_worker = true;
window.exported_project = true;
window.ms_use_server = false ;
</script><script type="text/javascript">//
          //
          // The game is started with the code below.
          // Once you have received the "started" signal (see below),
          // you can do the following:
          // 1) Inject functions or objects into the global context of the microStudio engine, example:
          //
          //   window.player.setGlobal("special_callback",function(x) { console.info(x) }) ;
          //   // Your microScript code can now call the "special_callback" function
          //
          // 2) Call microScript global functions from your JavaScript code, example:
          //
          //   window.player.call("call_me_from_javascript",[10,1000]) ;
          //   // arguments to the function call are provided as an array
          //
          // 3) Run a microScript code snippet from your JavaScript code, example:
          //
          //   window.player.exec("player.position_x = 50",function(result) { console.log(result) ; }) ;
          //

          window.addEventListener("load",function() {
            window.player = new Player(function(event) {
              if (event.name == "started") {
                // signal that the game is started
              }
              else if (event.name == "log") {
                // console.info(event.data) ;
              }
            }) ;
            document.body.focus() ;
          }) ;




</script><script src="compiler.js"></script><script src="parser.js"></script><script src="processor.js"></script><script src="program.js"></script><script src="routine.js"></script><script src="runner.js"></script><script src="token.js"></script><script src="tokenizer.js"></script><script src="transpiler.js"></script><script src="microengine.js"></script></body><script id="code" type="text/x-microscript">


function()
// takes an angle in degrees and returns a vector in the form of a list [x, y]
// the elements [x, y] of this direction vector can then be multiplied by a
// certain speed (in pixels per frame) to move an entity on the screen
angleToVector = function(angle)
  return [cosd(angle), sind(angle)]
end

// discover the name of the sprite portion at an (x, y) position in the world
// NOTE: the draw width/height is not the width of the map, but how width/high
// you draw it in the game
checkCollision = function(x, y, map_name, map_draw_width, map_draw_height)
  local grid_x = floor((x + map_draw_width / 2) / (map_draw_width / maps[map_name].width))
  local grid_y = floor((y + map_draw_height / 2) / (map_draw_height / maps[map_name].height))
  return maps[map_name].get(grid_x, grid_y)
end

// checks to see if the mouse is touching/hovering over a rectangle
// useful for detecting hover/click on buttons
checkRectMouseHover = function(x, y, width, height)
  local hover = true
  if mouse.x < (x - width/2) then hover = false end
  if mouse.x > (x + width/2) then hover = false end
  if mouse.y < (y - height/2) then hover = false end
  if mouse.y > (y + height/2) then hover = false end
  return hover
end

// returns a random item from a list
choose = function(lst)
  local index = random.nextInt(lst.length)
  return lst[index]
end

// keep a value within a set range
// useful for keeping a player on the screen etc.
// NOTE: returns the new value, does not automatically change it
clamp = function(value, lower_limit, upper_limit)
  local val = max(value, lower_limit)
  val = min(val, upper_limit)
  return val
end

// takes screen co-ordinates (not map coord) and replaces the map square with a blank
// useful for removing items from the map when collecting gems etc.
deleteMapItem = function(x, y, map_name, map_draw_width, map_draw_height)
  local grid_x = floor((x + map_draw_width / 2) / (map_draw_width / maps[map_name].width))
  local grid_y = floor((y + map_draw_height / 2) / (map_draw_height / maps[map_name].height))
  maps[map_name].set(grid_x, grid_y, " ")
end

// takes screen co-ordinates (not map coord) and replaces the map square with a blank
// useful for removing items from the map when collecting gems etc.
deleteMapItem = function(x, y, map, map_draw_width, map_draw_height)
  local grid_x = floor((x + map_draw_width / 2) / (map_draw_width / maps[map].width))
  local grid_y = floor((y + map_draw_height / 2) / (map_draw_height / maps[map].height))
  maps[map].set(grid_x, grid_y, " ")
end

// find the distance between object 1 and object 2
// useful for a simple circular collision detection
distance = function(x1, y1, x2, y2)
  local a = x2 - x1
  local b = y2 - y1
  local c = sqrt(pow(a, 2) + pow(b, 2))
  return c
end

// returns a number that moves smoothly between .4 and 1
// useful for flashing text if used to set the alpha each frame
getFlashValue = function(seconds_per_flash = 1.5)
  return pow(cos(system.time()/1000*PI/seconds_per_flash), 2) * 0.6 + .4
end

// finds the angle in degrees from point 1 to point 2
getAngle = function(x1, y1, x2, y2)
  return atan2d(y2 - y1, x2 - x1)
end

// returns a number that moves smoothly between .4 and 1
// very useful for flashing text if used to set the alpha each frame
getFlashValue = function(seconds_per_flash = 1.5)
  return pow(cos(system.time()/1000*PI/seconds_per_flash), 2) * 0.6 + .4
end

// slowly transition a variable to value for smooth tween effects
moveToward = function(current_value, target, amount)
  local new_value = 0
  if current_value == target then
    new_value = current_value
  elsif current_value < target then
    new_value = current_value + amount
    if new_value > target then new_value = target end
  elsif current_value > target then
    new_value = current_value - amount
    if new_value < target then new_value = target end  
  end
  return new_value
end

// sets the length of a movement vector to 1, making it a direction vector
// useful for directions as it can then be multiplied by an object's speed
normalize = function(vector)
  local x = vector[0]
  local y = vector[1]
  local v = sqrt(pow(x, 2) + pow(y, 2))
  local new_x = x / v
  local new_y = y / v
  return [new_x, new_y]
end

// returns a random number (float/with decimals) within the range [low, high)
randRange = function(low, high)
  return (high - low) * random.next() + low
end

// removes objects from a given list that have a property "delete = true"
// useful for deleting enemies, bullets etc. run at the end of each frame
// then simply set object.delete = true to ensure it's deletion
removeDeleted = function(object_list)
  for i = object_list.length - 1 to 0 by -1
    if object_list[i].delete then 
      object_list.removeAt(i) 
    end
  end
end

// find the diagonal length of a vector
vectorLength = function(x, y)
  return sqrt(pow(x, 2) + pow(y, 2))
end

// takes a (direction or movement) vector in the form of a list [x, y]
// returns an angle in degrees
vectorToAngle = function(vec)
  return atan2d(vec[1], vec[0])
end

// makes the object wrap around the screen when moving off the edge
// note: object must have x and y fields (variables)
wrap = function(obj, leeway = 0)
  if obj.x + leeway < -screen.width/2 then
    obj.x = screen.width/2 + leeway
  elsif obj.x - leeway > screen.width/2 then
    obj.x = -screen.width/2 - leeway
  end 
  if obj.y + leeway < -screen.height/2 then
    obj.y = screen.height/2 + leeway
  elsif obj.y - leeway > screen.height/2 then
    obj.y = -screen.height/2 - leeway
  end 
end

// calculate the map grid position of a specific x value in the world
xpos_to_grid = function(x, map_columns, map_draw_width)
  local column_draw_width = map_draw_width / map_columns
  return floor((x + map_draw_width / 2) / column_draw_width)
end

// calculate the map grid position of a specific y value in the world
ypos_to_grid = function(y, map_rows, map_draw_height)
  local row_draw_height = map_draw_height / map_rows
  return floor((y + map_draw_height / 2) / row_draw_height)
end



end()



function()
init = function()
  player = object end
  player.x = 0
  player.y = 0
  player.speed = 2
end

update = function()
  
  player.x = clamp(player.x, -165, 165)
  player.y = clamp(player.y, -80, 80)  
  
  if keyboard.UP then
    player.y += player.speed
  end
  
  if keyboard.DOWN then
    player.y -= player.speed
  end
  
  if keyboard.RIGHT then
    player.x += player.speed
  end
  
  if keyboard.LEFT then
    player.x -= player.speed
  end

end

draw = function()
    screen.clear()
    screen.fillRect(0,0,screen.width,screen.height,"rgb(57,0,57)")
    screen.drawSprite("icon",player.x,player.y,20)
end
end()



</script></html>